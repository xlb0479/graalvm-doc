# 本地镜像

本地镜像(Native Image)技术是将Java代码提前编译成二进制，也就是**本地可执行文件**。这种文件中仅包含了运行时需要的代码，也就是应用类、标准库类、语言运行时，以及JDK中静态链接的本地代码。

通过本地镜像生成的可执行文件拥有以下优势：

- 仅使用JVM所需的一部分资源，运行成本更低
- 毫秒级启动
- 无需热身，迅速达到最佳性能
- 可以打入轻量级容器镜像快速部署
- 减少受攻击面

这种可执行文件需要由**本地镜像生成器**`native-image`创建，它会处理应用中的类以及[其他元数据](../可达性元数据/可达性元数据.md)，根据指定的操作系统和架构来创建二进制文件。首先，`native-image`会对你的代码做静态分析，判断哪些类和方法是在运行时**可达的**(reacheable)。然后它就开始将类、方法、以及资源文件编译到二进制文件中。整个过程被称为**构建时**(build time)，这跟Java的源码编译成字节码有明显的不同。

`native-image`默认用来构建**本地可执行文件**(native executable)，但也可以用来构建**本地共享库**(native shared library)。这里我们先聚焦于构建本地可执行文件，如果像了解本地共享库请看[这里](../与本地代码的互操作性/与本地代码的互操作性.md)。

## 准备工作

`native-image`工具就在你的GraalVM安装目录的`bin`目录中，它依赖本地的工具链（C头文件、`glibc-devel`、`zlib`、`gcc`、`libstdc++-static`）。如果没装的话可以用本机的软件包管理工具安装即可。根据操作系统选择对应的安装方法。

### Linux

在Oracle Linux上用`yum`：

```shell
sudo yum install gcc glibc-devel zlib-devel
```

一些Linux发行版中可能还需要`libstdc++-static`，启用对应仓库即可安装（Oracle Linux 7上的*ol7_optional_latest*，Oracle Linux 8和9上的*ol8_codeready_builder*）。

Ubuntu上面要用`apt-get`：

```shell
sudo apt-get install build-essential libz-dev zlib1g-dev
```

其他系统用`dnf`：

```shell
sudo dnf install gcc glibc-devel zlib-devel libstdc++-static
```

## 构建Native可执行文件

`native-image`工具以Java字节码作为输入。可以基于一个类文件、jar包，或者Java 9出的模块来构造native可执行文件。

### 用Class文件来构造

在当前目录下使用Java类文件构建native可执行文件：

```shell
native-image [options] class [imagename] [options]
```

以HelloWorld为例。

1. 创建*HelloWorld.java*：

    ```java
    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, Native World!");
        }
    }
    ```

2. 编译并构建native可执行文件：

    ```shell
    javac HelloWorld.java
    native-image HelloWorld
    ```

    此时在当前目录下会创建出名为`helloworld`的可执行文件。

3. 运行程序：

    ```shell
    ./helloworld
    ```

    可以看下资源消耗：

    ```shell
    time -f 'Elapsed Time: %e s Max RSS: %M KB' ./helloworld
    # Hello, Native World!
    # Elapsed Time: 0.00 s Max RSS: 7620 KB
    ```